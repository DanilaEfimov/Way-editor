Пусть дан граф с v - количеством вершин и e - количеством ребер.
(в примерах не записываются и не учитываются в длине поля фиксированной длины. Смотреть в дескрипторах)
МАТРИЦЫ:
----------------------------------
граф как матрица смежности: Массив
Неориентированный граф:
В случае неориентированного графа нам достаточно хранить только v(v-1)/2 логических значения. Мы не храним информацию об элементах матрицы на местах (i, j) таких, что i >= j (элементы на местах (i, j) и (j, i) равны между собой, а все диагональные равны нулю). Таким образом граф будет представлять собой последовательность бит длинной v(v-1)/2 (количество вершин однозначно определяется по количеству бит). Пустой граф можно представить символично и однозначно одним нулевым битом [ни один другой граф не будет так записываться]. Граф, состоящий из одной вершины по аналогии с пустым уже не получится обозначить за 1, так как единице соответствует полный граф из двух вершин. Для избегания этой неоднозначности добавим бит-признак графа с одной вершиной. 
Пустой граф: 0
Полный граф из четырех вершин: 111111
Граф из одной вершины: 11 (заметим, что только в таком случае длина цепочки равна 2-м. Это из-за дополнительного бита-флага.)
Дескриптор:
Сначала читается поле фиксированной длины (16 бит, например), в котором хранится количество вершин - v.
Первые v-1 бит - смежность первой вершины с остальными, следующие v-2 бита, соответственно, - смежность второй вершины с остальными, кроме первой и т.д.
В случае графа с одной вершиной - два единичных бита.
Ориентированный граф:
В случае ориентированного графа у нас уже нет гарантий, что матрица симметрична и вообще говоря это не так. Нам придется хранить и эту информацию и меньше, чем по 1 биту на каждое место матрицы мы выделить не можем. В таком случае длины цепочки бит составит v(v-1). Правила для пустого и графа с одной вершиной остаются такими же, как и для ориентированного графа (это естественно, так как в этих случаях в графе нет ребер, следовательно и различий между ориентированным и неориентированным графом не может быть). Таким образом мы будем хранить граф как последовательность бит вдвое длиннее, чем для ориентированного графа.
Пустой граф: 0
Полный граф из четырех вершин: 111111 111111
Граф из одной вершины: 11
Дескриптор: 
Сначала читается поле фиксированной длины (16 бит, например), в котором хранится количество вершин - v.
По дескриптору для неориентированного графа записываются элементы матрицы смежности выше главной диагонали, затем - ниже в обратном порядке (1 бит - связность предпоследней вершины с последней, два бита - связность "предпредпоследней" вершины с предпоследней и последней соответственно т.д.)
----------------------------------
Граф как матрица Кирхгофа: Массив
Неориентированный граф:
Так как матрица Кирхгофа симметричная, нам как и в случае матрицы смежности достаточно хранить половину матрицы вместе с диагональю.
Здесь у нас есть два способа сохранить главную диагональ: Выделить для каждой вершины поле фиксированной длины (такой же длины, как и поле, хранящее количество вершин, например, 16 бит); Выделять поля длины L = (int)log('length') + 1. Если идти по первому пути, то это окажется очень избыточно (это будет оправдано для графов, содержащих большие клики), затраты на хранение диагонали матрицы Кирхгофа в таком случае составят O(v) с большой (по меркам дескриптора) константой. Если пойти по второму пути, то затраты на хранение диагонали составят уже O(vlog(v)), но этом случае log(v) никогда не превысит ту константу.
Пустой граф: 0
Полный граф из четырех вершин: 11 11 11 11 111111
Граф из одной вершины: 1 (здесь 1 - количество вершин, после которого по дескриптору ничего не идет)
Дескриптор:
Сначала идет поле фиксированной длины, в котором хранится количество вершин в графе. Далее перечисляются диагональные элементы матрицы Кирхгофа (длину последовательности бит, выделяемой под хранение диагонали, можно однозначно определить по количеству вершин).
Ориентированный граф:
Здесь все изменения аналогичны матрице смежности. Мы так же теперь не сможем игнорировать вторую половину матрицы и нам придется ее сохранить. 
Пустой граф: 0
Полный граф из четырех вершин: 11 11 11 11 111111 111111
Граф из одной вершины: 1 (здесь 1 - количество вершин, после которого по дескриптору ничего не идет)
Дескриптор:
По правилам для неориентированного графа записывается верхняя половина матрицы Кирхгофа. Затем дописывается вторая половина матрицы в обратном порядке (1 бит - связность предпоследней вершины с последней, два бита - связность "предпредпоследней" вершины с предпоследней и последней соответственно т.д.).
----------------------------------
граф как матрица инцидентности: Массив
Неориентированный граф:
В матрице инцидентности хранится избыточное количество информации. Ведь каждое ребро графа соединяет не более двух вершин (в случае с матрицей инцидентности можно представить любой, даже гиперграф, тем более петли). Затраты на хранение такой таблицы составляют O(v*e) или O(v^3).
Так как матрица имеет размеры v x e, нам надо выделить фиксированное поле для хранения количества ребер. Заметим, что оно должно быть вдвое длиннее поля для хранения количества вершин (если для количества вершин выделено, например 16 бит, то для хранения ребер - 32). Далее можно выписывать столбцы или строки матрицы последовательно. 
Но можно немного сэкономить и воспользоваться тем наблюдением, что в строке (именно в строке перечислены вершины инцидентные данному ребру) не может быть больше двух единиц. То есть можно записывать столбец только до того момента, пока не будут выписаны обе единицы (при чтении однозначно можно восстановить граф).
Пустой граф: (после пустых полей для записи количества вершин и ребер ничего не записывается)
Полный граф из четырех вершин: 11   101  1001 011  0101 0011
Полная матрица имела бы вид:   1100 1010 1001 0110 0101 0011
Напоминаем, что в примерах мы не выписываем поля фиксированной длины (в данном случае 48 бит)
Граф из одной вершины: (после полей для записи количества вершин и ребер ничего не записывается)
Дескриптор:
Сначала в два поля для количества вершин и ребер (второе вдвое длиннее первого) записывается количество вершин и ребер. После выписываются строки матрицы смежности. Каждая строка выписывается до второй единицы, после начинается следующая.

Так как массив последовательная структура, операции удаления вершины будут требовать полной перезаписи графа. В отличие от добавления вершины или ребра.
__________________________________

СПИСКИ:
----------------------------------
граф как список смежности:
Частные случаи:
Дерево: Разделенные множества ("Графы и Алгоритмы" В.Е.Алексеев В.А.Таланов стр. 152.. лекция 19..)
Разделенные множества - это абстрактный тип данных, предназначенный для представления коллекции, состоящей из некоторого числа k попарно непересекающихся подмножеств заданного множества.
Неориентированное дерево:
Самый простой и очевидный способ представить разделенные множества - это массив. Каждой ячейке фиксированной длины хранить номер канонического элемента. Пусть нам дано множество вершин дерева, разделим его на v подмножеств, в i-м подмножестве будут храниться дети/потомки (далее - синонимы) i-й вершины (очевидно, они не пересекаются). Тогда в соответствующем массиве длины v * sizeof(ячейки) бит в i-й ячейке будет записан номер родителя/предка (далее - синонимы) i-й вершины. Корень дерева будет являться сам себе родителем (также можно указать несуществующего родителя для определения корня). Для небольшой экономии можно хранить количество сделать размер ячейки зависимым от количества вершин, чтобы не было избыточности, сделать размер ячейки длиной (int)log(v) + 1. 
Также есть способ представления дерева как v подмножеств, в i-м подмножестве будут храниться потомки i-й вершины. Корень дерева аналогично предыдущему случаю можно обозначить указанием на самого себя (или несуществующего сына)
Время операций "Создать" (создать дерево), "Объединить" (объединить два потомка одного родителя), "Найти": O(1), O(v), O(1).
----------------------------------
Ориентированное дерево:
Здесь появляется необходимость хранить информацию о характере отношения между потомком и предком. Для каждого ребра потребуется дополнительный бит-направления (0 - от предка к потомку, например, 1 - от потомка к предку).
Конечно, есть способы сэкономить и на этом, но в любом случае издержки составят O(e) или O(v^2).
Время операций при этом никак не изменится.
----------------------------------
Общие случаи:
Неориентированный граф: Массив
В массиве будут последовательно расположены списки смежности каждой вершины. Каждый список можно организовать так: явно перечислить все смежные вершины (признаком конца списка может быть номер несуществующей вершины, например, ноль) выделяя под каждую поле длины (int)log(v) + 1. Также необходима поле для хранения количества вершин - v.
Пустой граф: (после поля для записи количества вершин ничего не записывается)
Полный граф из четырех вершин: 010 011 100 000 | 001 011 100 000 | 001 010 100 000 | 001 010 011 000
Заметим, что длина каждого абстрактного поля равна 3 битам, то есть (int)log(4) + 1.
Граф из одной вершины: (после поля для записи количества вершин ничего не записывается)
Дескриптор:
Первым идет поле фиксированного размера для хранения количества вершин, далее последовательно перечисляются смежные вершины для текущей (длина полей для хранения смежных вершин описана выше). Признаком конца текущего списка является номер несуществующей вершины, например, нуля.
----------------------------------
Ориентированный граф: Массив
Здесь появляется необходимость хранить информацию о характере отношения между потомком и предком. Для каждого ребра потребуется дополнительный бит-направления (0 - от предка к потомку, например, 1 - от потомка к предку).
Конечно, есть способы сэкономить и на этом, но в любом случае издержки составят O(e) или O(v^2).
Время операций при этом никак не изменится.
Пустой граф: (после поля для записи количества вершин ничего не записывается)
Полный граф из четырех вершин: 0010 0011 0100 0000 | 1001 0011 0100 0000 | 1001 1010 0100 0000 | 1001 1010 1011 0000
Заметим, что длина каждого абстрактного поля равна 3 битам, то есть (int)log(4) + 2.
Граф из одной вершины: (после поля для записи количества вершин ничего не записывается) 
Дескриптор:
Первым идет поле фиксированного размера для хранения количества вершин, далее последовательно перечисляются смежные вершины для текущей (длина полей для хранения смежных вершин описана выше). Признаком конца текущего списка является номер несуществующей вершины, например, нуля. Но теперь в состав поля вершины в списке смежности добавлен бит-направление (старший бит поля).
----------------------------------
граф как список ребер: Массив
Частные случаи:
Неориентированный связный граф:
Самым простым, но затратным способом будет перечислить все ребра, выделив для каждого фиксированные поля. Но есть несколько способов сэкономить память при хранении ребер. Можно хранить сжать эту информацию вдвое, если использовать Эйлеров путь: вместо того, чтобы выписывать начало и конец каждого ребра можно рассмотреть конец одного из ребер как начало следующего. Как мы помним, не для каждого графа существует Эйлеров путь, чтобы отличать такие графы, мы будем хранить бит-флаг, признак существования Эйлерова пути. Если же граф не имеет Эйлерова пути, то после признака конца списка ребер будет дописано дополнительно последнее ребро. Опять, для нормализации длины полей нам потребуется хранить количество вершин в поле фиксированной длины. Признаком конца списка может быть пустое поле или вершина, с которой начинался путь. 
Пустой граф: (после поля для записи количества вершин ничего не записывается)
Полный граф из четырех вершин: 00 01 10 00 11 01 00 | 11 10
Заметим, что в полном графе из четырех вершин не существует Эйлерова пути, поэтому бит-флаг имеет значение, означающее это (например, 1), а значит после признака конца дописано не пройденное ребро. Также заметим, что представление графа в таком случае неоднозначно.
Граф из одной вершины: (после поля для записи количества вершин ничего не записывается)
Дескриптор (или разрядная сетка, кстати):
Сначала записывается количество вершин в поле фиксированной длины, далее идет бит-флаг. После полей фиксированной длины записываются вершины Эйлерова пути. Признак конца списка - вершина, с которой начинался список (или номер несуществующей вершины). По необходимости дописывается не пройденное в пути ребро.
Напоминаю, что количество вершин используется для вычисления длины поля, в которое будет записываться номера/индексы/идентификаторы вершин.
----------------------------------
Ориентированный связный граф:
Здесь появляется необходимость хранить информацию о характере отношения между вершинами. Для каждого ребра потребуется дополнительный бит-направления (0 - от предка к потомку, например, 1 - от потомка к предку). То есть в разрядной сетке поля для записи номера вершины появится бит-направление, он будет означать отношение текущей вершины к следующей. Вершины в пути будут указаны как для соответствующего неориентированного графа. Чтобы допустить кратные дуги, нам нужно сделать правила для определения конца списка строже. Теперь признак конца имеет вдвое большую длину и представляет собой петлю (недопустимый элемент).
Пустой граф: (после поля для записи количества вершин ничего не записывается)
Полный граф из четырех вершин: 000 001 010 000 011 001 100 101 110 100 111 101 101
Заметим, что в полном ориентированном графе каждая вершина имеет четную степень, причем степень входа равна степени выхода, следовательно, существует Эйлеров путь и дополнительно ребра не дописываются.
Граф из одной вершины: (после поля для записи количества вершин ничего не записывается)
Дескриптор:
Аналогично случаю с неориентированным графом, но перед записью ребра записывается бит-направление, а признак конца списка - петля.
