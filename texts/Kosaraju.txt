Дан ориентированный граф G с v вершинами. Требуется выделить в нем все компоненты сильной связности.
Алгоритм Косарайю:
1.	Инвертируем дуги исходного ориентированного графа.
2.	Запускаем поиск в глубину на этом обращённом графе, запоминая, в каком порядке выходили из вершин.
3.	Запускаем поиск в глубину на исходном графе, в очередной раз выбирая не посещённую вершину с максимальным номером в векторе, полученном в п.2.
4.	Полученные из п.3 деревья и являются сильно связными компонентами.

Рассмотрим алгоритм на примере графа заданного матрицей смежности:
Матрица смежности исходного графа G (v = 6):

________________________
|0   1   0   1   0   0 |
|                      |
|1   0   0   0   1   0 |
|                      |
|1   1   0   0   0   1 |
|                      |
|0   0   0   1   0   1 |
|                      |
|1   0   0   1   0   0 |
|                      |
|0   1   1   0   1   0 |

Эта матрица может храниться в памяти как битовый вектор:

010100 100010 110001 000101 100100 011010

(конечно, достаточно хранить половину элементов матрицы, но для демонстрационного примера это игнорируется)

1. Инвертируем ребра:
Эта операция очень просто описывается использованием двойной индексации. Элементы матрицы на местах (i, j) и (j, i) обмениваются
значениями. Действительно, если вершины не были соединены дугой, то они останутся так же не соединенными; если они были объединены одной
дугой, то эта дуга инвертируется; если же они были сильно связаны, то связность не нарушится.
Реализация инверсии ребра (i, j) (которое может отсутствовать) для битового вектора:
Пусть BASE - указатель на первый элемент битового вектора, которому соответствует матрица смежности графа G. 
Тогда соответствующие элементы матрицы находятся по адресам BASE[i*v + j] и BASE[j*v + i]. Эти элементы должны обменяться значениями.
Это делается как на первом семестре информатики, посредством вспомогательной переменной SWAP (роль этой переменной, например, может выполнять
один из регистров процессора). Получим последовательность трех присваиваний: 
SWAP = BASE[i*v + j], BASE[i*v + j] = BASE[j*v + i], BASE[j*v + i] = SWAP;
Эта операция проделывается для индексов элементов находящихся выше главной диагонали. (Если выполнить эту операцию для всех элементов,
тогда каждое ребро инвертируется дважды, что не даст нужного результата первого шага алгоритма. Так же очевидно, что петли, при
наличии, инвертировать не нужно.)
Короче говоря, этот шаг равносилен получению транспонированной матрицы к матрице смежности графа G.
Получим матрицу инвертированного графа G^T:

________________________
|0   1   1   0   1   0 |
|                      |
|1   0   1   0   0   1 |
|                      |
|0   0   0   0   0   1 |
|                      |
|1   0   0   1   1   0 |
|                      |
|0   1   0   0   0   1 |
|                      |
|0   0   1   1   0   0 |

2. Поиск в глубину в обращенном графе (запоминая порядок обхода вершин или "измеряя глубину"):
Подробности реализации алгоритма поиска в глубину пропускаются. Каждая вершина при ее исследовании помечается соответствующей
меткой, а ее индекс помещается в соответствующий вектор (который потребуется на третьем шаге). По итогу мы получим DFS-дерево.
Можно договориться по умолчанию начинать обход в глубину из вершины с индексом 0, что логично.
Пусть DEPTH - указатель на первый элемент вектора, в котором хранятся все исследованные вершины в порядке их открытия (то есть указатель
на первую открытую вершину с индексом 0, по договоренности). В нашем случае мы получим следующее содержание вектора:
0 (в десятичной системе счисления)


Доказательство: